{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///./lib/queue_array.ts","webpack:///./src/bfs.ts","webpack:///./src/grid.ts","webpack:///webpack/bootstrap","webpack:///./src/canvas.ts"],"sourcesContent":["\n/**\n * A homogeneous queue.\n * The first entry points to the index of the queue's head element,\n * the second entry points to the next empty index of the queue, and\n * the last entry holds the values (contents) of the queue.\n * @template T type of all queue elements\n */\nexport type Queue<T> = [number, number, Array<T>];\n\n/**\n * Constructs a queue without any elements.\n * @template T type of all queue elements\n * @returns Returns an empty queue.\n */\nexport function empty<T>(): Queue<T> {\n    return [0, 0, []];\n}\n\n/**\n * Checks whether a queue is empty.\n * @template T type of all queue elements\n * @param q queue to check for emptiness\n * @returns Returns true, if the queue q has elements, false otherwise.\n */\nexport function is_empty<T>(q: Queue<T>): boolean {\n    return q[0] === q[1];\n}\n\n/**\n * Adds an element to the queue.\n * @template T type of all queue elements\n * @param e element to add\n * @param q queue to modify\n * @modifies q by adding element e to the end\n */\nexport function enqueue<T>(e: T, q: Queue<T>) {\n    const tail_index = q[1];\n    q[2][tail_index] = e;\n    q[1] = tail_index + 1;  // update tail index\n}\n\n/**\n * Retrieves the first element of the queue.\n * @precondition Assumes q to be non-empty\n * @template T type of all queue elements\n * @param q queue to get the first element of\n * @returns Returns the element of the queue that was enqueued first.\n */\nexport function head<T>(q: Queue<T>): T {\n    const head_index = q[0];\n    return q[2][head_index];\n}\n\n/**\n * Removes the first element of a queue.\n * @precondition Assumes q to be non-empty\n * @template T type of all queue elements\n * @param q queue to remove the element from\n * @modifies q such that the element that was enqueued first is removed\n */\nexport function dequeue<T>(q: Queue<T>) {\n    const head_index = q[0];\n    q[0] = head_index + 1;\n}\n\n/**\n * Pretty-prints the contents of a queue to standard output.\n * @template T type of all queue elements\n * @param q queue to pretty-print\n */\nexport function display_queue<T>(q: Queue<T>) {\n    console.log(q[2].slice(q[0], q[1]));\n}","\nimport { AdjacencyList, generate2DGridAdjacencyList } from \"./grid\";\nimport {  empty, is_empty, head, dequeue, enqueue} from '../lib/queue_array';\n\n\nconst grid = generate2DGridAdjacencyList(20, 43);\n\n\n\n/* function bfs(start: number, goal: number, grid: AdjacencyList) {\n    let visited = empty<number>();\n    let queue = empty<number>();\n    enqueue(start, queue);\n\n    function visit(node: number) {\n        enqueue(node, visited);\n\n    }\n\n\n    while(!is_empty(queue)) {\n        const current = head(queue);\n        dequeue(queue);\n        \n        const adjList = grid.get(current);\n        adjList.forEach(node => {enqueue(node, queue)});\n\n\n    }\n} */\n\nexport function bfs(start: number, goal: number, grid: AdjacencyList): Array<number[]> {\n    let visited = new Set<number>(); // Set to keep track of visited nodes\n    let queue = empty<number>();\n    enqueue(start, queue);\n\n    let predecessors: Map<number, number> = new Map(); // To reconstruct the path\n\n    while (!is_empty(queue)) {\n        const current = head(queue);\n        dequeue(queue);\n\n        if (visited.has(current)) {\n            continue; // Skip if already visited\n        }\n\n        visited.add(current); // Mark as visited\n\n        if (current === goal) { // Goal check\n            // Reconstruct the path from goal to start\n            let path = [goal];\n            let step = goal;\n            while (predecessors.has(step) && step !== start) {\n                step = predecessors.get(step)!;\n                path.unshift(step); // Add step to the beginning of the path\n            }\n            const arrVisited = Array.from(visited);\n            return [path, arrVisited];\n        }\n\n        const neighbors = grid.get(current) || [];\n        neighbors.forEach(neighbor => {\n            if (!visited.has(neighbor)) {\n                predecessors.set(neighbor, current); // Set predecessor for path reconstruction\n                enqueue(neighbor, queue);\n            }\n        });\n    }\n\n    return []; // Return null if the goal is not reachable from the start\n}\n\n// Usage example with the grid from your previous code\nconst start = 0; // Start node\nconst goal = 17; // Goal node\n\nconst adjList = generate2DGridAdjacencyList(6, 5);\nconst path = bfs(start, goal, adjList);\n\nconsole.log(path); // Log the path from start to goal","/**\r\n * Generates a 2D grid represented as an adjacency list, where each node is connected\r\n * to its immediate neighbors in the cardinal directions (North, South, East, West).\r\n * This function assumes a rectangular grid layout. Each node in the grid is assigned\r\n * a unique identifier, starting from 0 at the top-left corner, moving left to right\r\n * and top to bottom. The adjacency list is implemented as a Map, where each key is\r\n * a node identifier, and the corresponding value is an array of identifiers for\r\n * adjacent nodes.\r\n *\r\n * @param {number} rows - The number of rows in the grid.\r\n * @param {number} cols - The number of columns in the grid. Together with rows, it defines the size of the grid.\r\n * @returns {AdjacencyList} - The adjacency list representing the 2D grid. The type `AdjacencyList` is a Map\r\n *                            where the key is a number (node identifier) and the value is an array of numbers\r\n *                            (identifiers for adjacent nodes).\r\n *\r\n * @example\r\n * // Generate a 3x3 grid\r\n * const adjList = generate2DGridAdjacencyList(3, 3);\r\n * console.log(adjList);\r\n * // Map(9) {\r\n * //   0 => [ 1, 3 ],\r\n * //   1 => [ 0, 2, 4 ],\r\n * //   2 => [ 1, 5 ],\r\n * //   3 => [ 0, 4, 6 ],\r\n * //   4 => [ 1, 3, 5, 7 ],\r\n * //   5 => [ 2, 4, 8 ],\r\n * //   6 => [ 3, 7 ],\r\n * //   7 => [ 4, 6, 8 ],\r\n * //   8 => [ 5, 7 ]\r\n * // }\r\n *\r\n * Notes:\r\n * - Nodes at the edges of the grid will have fewer adjacent nodes since they cannot connect outside the grid boundaries.\r\n * - This function can be used to represent graphs for various applications such as pathfinding, grid-based games, and network simulations.\r\n */\r\nexport type AdjacencyList = Map<number, number[]>;\r\nexport function generate2DGridAdjacencyList(rows: number, cols: number): AdjacencyList {\r\n    let adjList: AdjacencyList = new Map();\r\n\r\n    for (let row = 0; row < rows; row++) {\r\n        for (let col = 0; col < cols; col++) {\r\n            let nodeId = row * cols + col; // Unique ID for each node\r\n            let edges: number[] = [];\r\n\r\n            // North\r\n            if (row > 0) edges.push(nodeId - cols);\r\n            // South\r\n            if (row < rows - 1) edges.push(nodeId + cols);\r\n            // East\r\n            if (col < cols - 1) edges.push(nodeId + 1);\r\n            // West\r\n            if (col > 0) edges.push(nodeId - 1);\r\n\r\n            adjList.set(nodeId, edges);\r\n        }\r\n    }\r\n\r\n    return adjList;\r\n}\r\n// access grid position by writing console.log(adjList.get(gridNr));\r\n\r\nexport function removeNode(adjList: AdjacencyList, nodeId: number, rows: number, cols: number): void {\r\n    // Remove the node itself\r\n    adjList.delete(nodeId);\r\n\r\n    // Potential neighbors\r\n    const neighbors = [\r\n        nodeId - 1,    // West\r\n        nodeId + 1,    // East\r\n        nodeId - cols, // North\r\n        nodeId + cols  // South\r\n    ];\r\n\r\n    // Remove the node from its neighbors' adjacency lists\r\n    neighbors.forEach(neighborId => {\r\n        if (adjList.has(neighborId)) {\r\n            const updatedEdges = adjList.get(neighborId)!.filter(edge => edge !== nodeId);\r\n            adjList.set(neighborId, updatedEdges);\r\n        }\r\n    });\r\n}\r\n\r\nexport function addNode(adjList: AdjacencyList, nodeId: number, rows: number, cols: number): void {\r\n    const row = Math.floor(nodeId / cols);\r\n    const col = nodeId % cols;\r\n    const edges: number[] = [];\r\n\r\n    // Determine valid adjacent nodes based on the grid structure\r\n    if (row > 0) edges.push(nodeId - cols);    // North\r\n    if (row < rows - 1) edges.push(nodeId + cols); // South\r\n    if (col > 0) edges.push(nodeId - 1);       // West\r\n    if (col < cols - 1) edges.push(nodeId + 1);   // East\r\n\r\n    // Add the node back with its edges\r\n    adjList.set(nodeId, edges);\r\n\r\n    // Add this node back to its neighbors' adjacency lists\r\n    edges.forEach(neighborId => {\r\n        if (adjList.has(neighborId) && !adjList.get(neighborId)!.includes(nodeId)) {\r\n            adjList.get(neighborId)!.push(nodeId);\r\n        }\r\n    });\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {generate2DGridAdjacencyList, addNode, removeNode } from \"./grid\";\r\nimport {bfs} from \"./bfs\";\r\n// Get the canvas element by its ID\r\nconst canvas = document.getElementById('myCanvas') as HTMLCanvasElement;\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\n// Get the 2D rgoalering context\r\nconst ctx = canvas.getContext('2d');\r\n\r\n// grid definitions\r\nconst fillColor = '#FF0000'; // Fill color for the squares\r\nconst gridOrigin = canvas.height * 0.2;\r\nconst gridEnd = canvas.height * 0.8;\r\nconst nOfSquares = 20;\r\nconst gridSize = (gridEnd - gridOrigin) / nOfSquares;\r\nconst rows = 20;\r\nconst cols = 20;\r\nlet grid = generate2DGridAdjacencyList(20, 20);\r\nconsole.log(grid);\r\n\r\nlet start = {\r\n    placed: false,\r\n    row: -1,\r\n    col: -1,\r\n}\r\nlet startGridNode: number = 20;\r\nlet goal = {\r\n    placed: false,\r\n    row: -1,\r\n    col: -1,\r\n}\r\nlet goalGridNode: number = 203;\r\n\r\n\r\n// Function to draw a rectangular grid of squares on a canvas\r\n/**\r\n * Draws a rectangular grid of squares on a canvas.\r\n * @param {number} nOfSquares - The number of squares in each row/column of the grid.\r\n * @param {string} gridColor - The color of the grid lines.\r\n * @throws {Error} If the canvas 2D context cannot be obtained.\r\n */\r\nfunction drawGrid(nOfSquares: number, gridColor: string) {  \r\n\r\n    // check there is a canvas\r\n    if (!ctx) {\r\n        console.error('Failed to get the canvas 2D context');\r\n        return;\r\n    }\r\n  \r\n    // Set the color for the grid lines\r\n    ctx.strokeStyle = gridColor;\r\n  \r\n  \r\n    // Draw grid lines\r\n    for (let gridX = 0; gridX <= nOfSquares; gridX++) {\r\n        for (let gridY = 0; gridY <= nOfSquares; gridY++) {\r\n            const x = gridX * gridSize + gridOrigin;\r\n            const y = gridY * gridSize + gridOrigin;\r\n            ctx.strokeStyle = \"black\";\r\n            ctx.strokeRect(x, y, gridSize, gridSize);\r\n            ctx.fillStyle = \"white\";\r\n            ctx.fillRect(x,y, gridSize, gridSize);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Toggles the fill state of a square in a grid on the canvas.\r\n * @param {HTMLCanvasElement} canvas - The canvas element.\r\n * @param {number} row - The row index of the square to toggle.\r\n * @param {number} col - The column index of the square to toggle.\r\n * @param {number} nOfSquares - The number of squares in each row/column of the grid.\r\n * @param {string} fillColor - The color to fill the square with.\r\n * @param {boolean} isFilled - Whether the square is already filled with the target color.\r\n */\r\ncanvas.addEventListener('mousedown', (event: MouseEvent) => {\r\n    function isFilled(): boolean {\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mouseX = event.clientX - rect.left;\r\n        const mouseY = event.clientY - rect.top;\r\n        // Get the pixel color data of the clicked position\r\n        if(ctx) {\r\n            const imageData = ctx.getImageData(mouseX, mouseY, 1, 1).data;\r\n            // Check if the clicked pixel is not white\r\n            if(mouseX > gridOrigin && mouseX < gridEnd + gridSize && mouseY > gridOrigin && mouseY < gridEnd + gridSize) {\r\n                if (!(\r\n                    // if not white\r\n                    imageData[0] === 255 &&\r\n                    imageData[1] === 255 &&\r\n                    imageData[2] === 255\r\n                )) {\r\n                    console.log(\"true\");\r\n                    return true;\r\n                } else {\r\n                    console.log(\"false\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        console.log(\"error\");\r\n        return false;\r\n    }\r\n\r\n    function placeBlock(isFilled: boolean) {\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mouseX = event.clientX - rect.left;\r\n        const mouseY = event.clientY - rect.top;\r\n         // Calculate the row and column in the grid based on the mouse position\r\n         const row = Math.floor((mouseY - gridOrigin) / gridSize);\r\n         const col = Math.floor((mouseX - gridOrigin) / gridSize);\r\n         if(mouseX > gridOrigin && mouseX < gridEnd + gridSize && mouseY > gridOrigin && mouseY < gridEnd + gridSize) {\r\n\r\n         switch (currentMode) {\r\n            case 'start':\r\n                if (isFilled) {\r\n                    toggleFill(canvas, row, col, nOfSquares, \"yellow\", true, \"start\");\r\n                    if(row === start.row && col === start.col) {\r\n                        start.placed = false;\r\n                        startGridNode = -1;\r\n\r\n                    } else {\r\n                        toggleFill(canvas, start.row, start.col, nOfSquares, \"yellow\", true, \"start\");\r\n                        startGridNode = col+20*row;\r\n\r\n                    }\r\n                } else {\r\n                    if (start.placed === true) {\r\n                        toggleFill(canvas, start.row, start.col, nOfSquares, \"yellow\", true, \"start\");\r\n                        toggleFill(canvas, row, col, nOfSquares, \"yellow\", false, \"start\");\r\n                    } else {\r\n                        toggleFill(canvas, row, col, nOfSquares, \"yellow\", false, \"start\");\r\n                        start.placed = true;\r\n                        startGridNode = col+20*row;\r\n\r\n                    }\r\n                }\r\n                start.row = row;\r\n                start.col = col;\r\n                break;\r\n            case 'goal':\r\n                if (isFilled) {\r\n                    toggleFill(canvas, row, col, nOfSquares, \"green\", true, \"goal\");\r\n                    if(row === goal.row && col === goal.col) {\r\n                        goal.placed = false;\r\n                        goalGridNode = -1;\r\n                    } else {\r\n                        toggleFill(canvas, goal.row, goal.col, nOfSquares, \"green\", true, \"goal\");\r\n                    }\r\n                } else {\r\n                    if (goal.placed === true) {\r\n                        toggleFill(canvas, goal.row, goal.col, nOfSquares, \"green\", true, \"goal\");\r\n                        toggleFill(canvas, row, col, nOfSquares, \"green\", false, \"goal\");\r\n                        goalGridNode = col+20*row;\r\n                    } else {\r\n                        toggleFill(canvas, row, col, nOfSquares, \"green\", false, \"goal\");\r\n                        goal.placed = true;\r\n                        goalGridNode = col+20*row;\r\n                    }\r\n                }\r\n                goal.row = row;\r\n                goal.col = col;\r\n                break;\r\n            case 'wall':\r\n                if (isFilled) {\r\n                    toggleFill(canvas, row, col, nOfSquares, \"red\", true, \"wall\");\r\n                } else {\r\n                    toggleFill(canvas, row, col, nOfSquares, \"red\", false, \"wall\");\r\n                }\r\n                break;\r\n            default:\r\n                console.error('No mode selected');\r\n        }\r\n    }\r\n    }\r\n\r\n    placeBlock(isFilled());\r\n\r\n});\r\n\r\n\r\nfunction toggleFill(canvas: HTMLCanvasElement, row: number, col: number, nOfSquares: number, fillColor: string, isFilled: boolean, type: string) {\r\n    // Get the 2D rgoalering context for the canvas\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    // Check there is a canvas\r\n    if (!ctx) {\r\n        console.error('Failed to get the canvas 2D context');\r\n        return;\r\n    }\r\n    // Calculate coordinates of the clicked square\r\n    const x = col * gridSize + gridOrigin;\r\n    const y = row * gridSize + gridOrigin;\r\n\r\n    // Get the color data of the clicked square\r\n    // Get the color data of the clicked square\r\n\r\n    if (isFilled) {\r\n        // Clear the square if it's already filled with the target color\r\n        ctx.fillStyle = \"white\";\r\n        ctx.fillRect(x, y, gridSize, gridSize);\r\n        // Redraw the square border if necessary\r\n        ctx.strokeStyle = \"black\";\r\n        ctx.strokeRect(x, y, gridSize, gridSize);\r\n        const gridNode = col+20*row;\r\n        if(type === \"wall\") {\r\n            addNode(grid, gridNode+1, rows, cols);\r\n            console.log(\"node added\");\r\n        }\r\n    } else {\r\n        // Fill the square with the specified color if it's not filled\r\n        const gridNode = col+20*row;\r\n        if (type === \"wall\") {\r\n            removeNode(grid, gridNode, rows, cols)\r\n            console.log(\"node removed\");\r\n        }\r\n        ctx.fillStyle = fillColor;\r\n        ctx.fillRect(x, y, gridSize, gridSize);\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * Fills a path of squares on the canvas with a specified color.\r\n * @param {HTMLCanvasElement} canvas - The canvas element.\r\n * @param {number[]} path - An array containing indices of squares in the path.\r\n * @param {number} rows - The number of rows in the grid.\r\n * @param {number} cols - The number of columns in the grid.\r\n * @param {string} fillColor - The color to fill the squares with.\r\n */\r\nfunction fillPath(canvas: HTMLCanvasElement, path: number[], rows: number, cols: number, fillColor: string) {\r\n    // Get the 2D rgoalering context for the canvas\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    // Check there is a canvas\r\n    if (!ctx) {\r\n        console.error('Failed to get the canvas 2D context');\r\n        return;\r\n    }\r\n\r\n\r\n    // Fill each cell in the path\r\n    for(let i = 0; i < path.length; i++) {\r\n        const xPos = (path[i] % rows) * gridSize + gridOrigin;\r\n        const yPos = Math.floor(path[i] / rows) * gridSize + gridOrigin;\r\n        \r\n        // Fill the cell with the specified color\r\n        ctx.fillStyle = fillColor;\r\n        ctx.fillRect(xPos, yPos, gridSize, gridSize);\r\n    }\r\n}\r\n\r\nlet currentMode: 'start' | 'goal' | 'wall' | null = null;\r\n\r\ndocument.getElementById('startButton')?.addEventListener('click', () => {\r\n    currentMode = 'start';\r\n    console.log(\"start\");\r\n});\r\n\r\ndocument.getElementById('goalButton')?.addEventListener('click', () => {\r\n    currentMode = 'goal';\r\n    console.log(\"goal\");\r\n});\r\n\r\ndocument.getElementById('wallButton')?.addEventListener('click', () => {\r\n    currentMode = 'wall';\r\n    console.log(\"wall\");\r\n});\r\n\r\ndocument.getElementById('resetButton')?.addEventListener('click', () => {\r\n    //currentMode = 'wall';\r\n    //console.log(\"reset\");\r\n});\r\n\r\ndocument.getElementById('runButton')?.addEventListener('click', () => {\r\n    let [fastestPath, visited] = bfs(startGridNode, goalGridNode, grid);\r\n\r\n    if (fastestPath && fastestPath.length > 0) {\r\n        fillPath(canvas, visited, 20, 20, \"gray\");\r\n        fillPath(canvas, fastestPath, 20, 20, \"blue\");\r\n    } else {\r\n        console.error(\"No valid path found.\");\r\n    }\r\n});\r\n\r\n\r\n\r\ndrawGrid(20, \"black\");\r\ndocument.addEventListener('keydown', (event: KeyboardEvent) => {\r\n    console.log(goalGridNode);\r\n    console.log(startGridNode);\r\n    if (event.key === 'e' && startGridNode !== -1 && goalGridNode !== -1) {\r\n        \r\n    }\r\n});"],"names":["q","e","tail_index","head_index","console","log","slice","bfs","start","goal","grid","visited","Set","queue","empty","enqueue","predecessors","Map","current","head","dequeue","has","add","step","get","unshift","Array","from","forEach","neighbor","set","is_empty","generate2DGridAdjacencyList","path","rows","cols","adjList","row","col","nodeId","edges","push","delete","neighborId","updatedEdges","filter","edge","Math","floor","includes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","canvas","document","getElementById","width","window","innerWidth","height","innerHeight","ctx","getContext","gridOrigin","gridEnd","nOfSquares","gridSize","placed","startGridNode","goalGridNode","toggleFill","fillColor","isFilled","type","x","y","fillStyle","fillRect","strokeStyle","strokeRect","gridNode","addNode","removeNode","error","fillPath","i","length","xPos","yPos","addEventListener","event","rect","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","currentMode","placeBlock","imageData","getImageData","data","fastestPath","gridColor","gridX","gridY","drawGrid","key"],"sourceRoot":""}