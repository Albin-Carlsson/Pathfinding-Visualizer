{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///./lib/queue_array.ts","webpack:///./src/a-star.ts","webpack:///./src/bfs.ts","webpack:///./src/canvas.ts","webpack:///./src/dfs.ts","webpack:///./src/grid.ts","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["\n/**\n * A homogeneous queue.\n * The first entry points to the index of the queue's head element,\n * the second entry points to the next empty index of the queue, and\n * the last entry holds the values (contents) of the queue.\n * @template T type of all queue elements\n */\nexport type Queue<T> = [number, number, Array<T>];\n\n/**\n * Constructs a queue without any elements.\n * @template T type of all queue elements\n * @returns Returns an empty queue.\n */\nexport function empty<T>(): Queue<T> {\n    return [0, 0, []];\n}\n\n/**\n * Checks whether a queue is empty.\n * @template T type of all queue elements\n * @param q queue to check for emptiness\n * @returns Returns true, if the queue q has elements, false otherwise.\n */\nexport function is_empty<T>(q: Queue<T>): boolean {\n    return q[0] === q[1];\n}\n\n/**\n * Adds an element to the queue.\n * @template T type of all queue elements\n * @param e element to add\n * @param q queue to modify\n * @modifies q by adding element e to the end\n */\nexport function enqueue<T>(e: T, q: Queue<T>) {\n    const tail_index = q[1];\n    q[2][tail_index] = e;\n    q[1] = tail_index + 1;  // update tail index\n}\n\n/**\n * Retrieves the first element of the queue.\n * @precondition Assumes q to be non-empty\n * @template T type of all queue elements\n * @param q queue to get the first element of\n * @returns Returns the element of the queue that was enqueued first.\n */\nexport function head<T>(q: Queue<T>): T {\n    const head_index = q[0];\n    return q[2][head_index];\n}\n\n/**\n * Removes the first element of a queue.\n * @precondition Assumes q to be non-empty\n * @template T type of all queue elements\n * @param q queue to remove the element from\n * @modifies q such that the element that was enqueued first is removed\n */\nexport function dequeue<T>(q: Queue<T>) {\n    const head_index = q[0];\n    q[0] = head_index + 1;\n}\n\n/**\n * Pretty-prints the contents of a queue to standard output.\n * @template T type of all queue elements\n * @param q queue to pretty-print\n */\nexport function display_queue<T>(q: Queue<T>) {\n    console.log(q[2].slice(q[0], q[1]));\n}","import { AdjacencyList} from \"./grid\";\r\nimport { grid_origin, grid_size, rows } from './canvas';\r\ntype NodeInfo = {f: number, g: number, h: number}; // distances. g = to goal, h = from start, f = sum of g and h\r\n\r\n\r\n/**\r\n * Calculates distance between two nodes with manhattan distance, using\r\n * the global variables of the grid size\r\n * @param n1 current node\r\n * @param n2 goal node\r\n * @returns distance between \"n1\" and \"n2\"\r\n */\r\nfunction dist_to_node(n1: number , n2: number): number {\r\n    const current_x_pos = (n1 % rows) * grid_size + grid_origin;\r\n    const current_y_pos = Math.floor(n1 / rows) * grid_size + grid_origin;\r\n    \r\n    const goal_x_pos = (n2 % rows) * grid_size + grid_origin;\r\n    const goal_y_pos = Math.floor(n2 / rows) * grid_size + grid_origin;\r\n    \r\n    const x = Math.abs(goal_x_pos - current_x_pos);\r\n    const y = Math.abs(goal_y_pos - current_y_pos);\r\n    \r\n    const distance: number = x + y;\r\n\r\n    return distance;\r\n}\r\n\r\n/**\r\n * Calculates the shortest path according to the a* algorithm\r\n * @param {number} start start node\r\n * @param {number} goal  goal node\r\n * @param {AdjacencyList} grid  The grid as an adjacencyList\r\n * \r\n * @returns {Array<number[]>} an array of two values. First the shortest path. \r\n * Second, all the visited nodes. If no path is found the function returns an empty array\r\n * \r\n * @example\r\n * // Assuming a predefined AdjacencyList for a 3x3 grid\r\n * const result = a_star(0, 8, grid); // Find path from top-left to bottom-right\r\n * console.log(result[0]); // Logs the path from start to goal\r\n * console.log(result[1]); // Logs the visited nodes\r\n */\r\nexport function a_star(start: number, goal: number, grid: AdjacencyList): Array<Array<number>> {\r\n    const visited = new Set<number>(); // Evaluated nodes\r\n    const next = new Set<number>(); // Nodes to be evaluated\r\n    \r\n    \r\n    const predecessors: Map<number, number> = new Map(); // To reconstruct the path\r\n    const distance: Map<number, NodeInfo> = new Map(); // Store the f, g, and h values for each node\r\n    \r\n    // Initialize the start node\r\n    next.add(start);\r\n    distance.set(start, {f: 0, g: 0, h: dist_to_node(start, goal)});\r\n\r\n    while (next.size > 0) {\r\n        // Consider the node with the lowest f score in the open list\r\n        let current = Array.from(next).reduce((a, b) => distance.get(a)!.f < distance.get(b)!.f ? a : b);\r\n\r\n       if (current === goal) { // Goal check\r\n            // Construct the path\r\n            const path = [];\r\n            while (current !== undefined) {\r\n                path.unshift(current);\r\n                current = predecessors.get(current)!;\r\n            }\r\n\r\n            const arr_visited: Array<number> = Array.from(visited); \r\n            return [path, arr_visited]; // Return the path and all visited nodes\r\n        }\r\n\r\n        // Move the current node from the to visited\r\n        next.delete(current);\r\n        visited.add(current);\r\n\r\n        // Look at all neighbors of the current node\r\n        const neighbors = grid.get(current) || [];\r\n        neighbors.forEach(neighbor => {\r\n            // G value for neighbor\r\n            const new_g = distance.get(current)!.g + 1; \r\n\r\n            // Skip if neighbor is in the closed list, but allow reconsideration if a shorter path is found\r\n            if (visited.has(neighbor) && (distance.get(neighbor)?.g ?? Infinity) <= new_g) return;\r\n\r\n            if (!next.has(neighbor) || new_g < (distance.get(neighbor)?.g ?? Infinity)) {\r\n                // If an equal or better path is found, replace it\r\n                predecessors.set(neighbor, current);\r\n                distance.set(neighbor, { f: new_g + dist_to_node(neighbor, goal), // Update f, g, and h values\r\n                                         g: new_g,\r\n                                         h: dist_to_node(neighbor, goal) });\r\n\r\n                // Add the neighbor to the open list if it's not already there\r\n                if (!next.has(neighbor)) {\r\n                    next.add(neighbor);\r\n                } else if (visited.has(neighbor)) {\r\n                    // If the neighbor is in the closed list but a better path is found, it needs to be reconsidered\r\n                    visited.delete(neighbor);\r\n                    next.add(neighbor);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // Return an empty array if the goal is not reachable\r\n    return [];\r\n}\r\n","\nimport {AdjacencyList} from \"./grid\";\nimport {  empty, is_empty, head, dequeue, enqueue} from '../lib/queue_array';\n\n/**\n * Calculates the shortest path according to the bfs-algorithm\n * @param {number} start start node\n * @param {number} goal  goal node\n * @param {AdjacencyList} grid  The grid as an adjacencyList\n * \n * @returns {Array<number[]>} an array of two values. First the shortest path. \n * Second, all the visited nodes. If no path is found the function returns an empty array.\n * \n * @example\n * // Assuming a predefined AdjacencyList for a 3x3 grid\n * const result = bfs(0, 8, grid); // Find path from top-left to bottom-right\n * console.log(result[0]); // Logs the path from start to goal\n * console.log(result[1]); // Logs the visited nodes\n */\nexport function bfs(start: number, goal: number, grid: AdjacencyList): Array<Array<number>> {\n    const visited = new Set<number>(); // Set to keep track of visited nodes\n    const queue = empty<number>();\n    enqueue(start, queue);\n    \n    const predecessors: Map<number, number> = new Map(); // To reconstruct the path\n\n    while (!is_empty(queue)) {\n        const current = head(queue);\n        dequeue(queue);\n\n        if (visited.has(current)) {\n            continue; // Skip if already visited\n        }\n\n        visited.add(current); // Mark as visited\n\n        if (current === goal) { // Goal check\n            // Reconstruct the path from goal to start\n            const path = [goal];\n            let step = goal;\n            while (predecessors.has(step) && step !== start) {\n                step = predecessors.get(step)!;\n                path.unshift(step); // Add step to the beginning of the path\n            }\n            const arr_visited = Array.from(visited);\n            return [path, arr_visited];\n        }\n\n        const neighbors = grid.get(current) || [];\n        neighbors.forEach(neighbor => {\n            if (!visited.has(neighbor)) {\n                predecessors.set(neighbor, current); // Set predecessor for path reconstruction\n                enqueue(neighbor, queue);\n            }\n        });\n    }\n    \n    return []; // Return null if the goal is not reachable from the start\n}\n","import {generate_2d_grid_adjacency_list, add_node, remove_node} from \"./grid\";\r\nimport {bfs} from \"./bfs\";\r\nimport {dfs} from \"./dfs\";\r\nimport {a_star} from \"./a-star\";\r\n\r\n// Get the canvas element by its ID\r\nexport const canvas = document.getElementById('myCanvas') as HTMLCanvasElement;\r\ncanvas.width = window.innerWidth;\r\ncanvas.height = window.innerHeight;\r\n// Get the 2D rgoalering context\r\nconst ctx = canvas.getContext('2d');\r\n\r\n// grid definitions\r\nexport const grid_origin = canvas.height * 0.2;\r\nconst grid_end = canvas.height * 0.8;\r\nconst n_of_squares = 20;\r\nexport const grid_size = (grid_end - grid_origin) / n_of_squares;\r\nexport const rows = 20;\r\nconst cols = 20;\r\nlet grid = generate_2d_grid_adjacency_list(20, 20);\r\n\r\n\r\nconst start = {\r\n    placed: false,\r\n    row: -1,\r\n    col: -1,\r\n};\r\nlet start_grid_node = 20;\r\nconst goal = {\r\n    placed: false,\r\n    row: -1,\r\n    col: -1,\r\n};\r\nlet goal_grid_node = 203;\r\n\r\n\r\n/**\r\n * Draws a rectangular grid of squares on a canvas.\r\n * @param {number} n_of_squares - The number of squares in each row/column of the grid.\r\n * @throws {Error} If the canvas 2D context cannot be obtained.\r\n */\r\nfunction draw_grid(n_of_squares: number): void {  \r\n\r\n    // check there is a canvas\r\n    if (!ctx) {\r\n        console.error('Failed to get the canvas 2D context');\r\n        return;\r\n    }\r\n  \r\n  \r\n    // Draw grid lines\r\n    console.log(\"run\");\r\n    for (let grid_x = 0; grid_x < n_of_squares; grid_x++) {\r\n        for (let grid_y = 0; grid_y < n_of_squares; grid_y++) {\r\n            const x = grid_x * grid_size + grid_origin;\r\n            const y = grid_y * grid_size + grid_origin;\r\n            fill_square(x, y, grid_size, \"white\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Draws a canvas square on specified place on canvas with black border.\r\n * @param {number} x - x-coordinate for top right corner of rectangle including border\r\n * @param {number} y - y-coord\r\n * @param {number} grid_size -  size of rectangle in pixels\r\n * @param {string} color - inside color\r\n */\r\nexport function fill_square(x: number, y: number, grid_size: number, color: string): void {\r\n    if(ctx) {\r\n        const border_width = 2;\r\n        ctx.clearRect(x, y, grid_size, grid_size);\r\n        ctx.fillStyle = \"black\";\r\n        ctx.fillRect(x, y, grid_size, grid_size);\r\n        ctx.fillStyle = color;\r\n        ctx.fillRect(x, y, grid_size-border_width, grid_size-border_width);\r\n\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Toggles the fill state of a square in a grid on the canvas.\r\n * @param {HTMLCanvasElement} canvas - The canvas element.\r\n * @param {number} row - The row index of the square to toggle.\r\n * @param {number} col - The column index of the square to toggle.\r\n * @param {number} n_of_squares - The number of squares in each row/column of the grid.\r\n * @param {string} fill_color - The color to fill the square with.\r\n * @param {boolean} is_filled - Whether the square is already filled a color.\r\n */\r\ncanvas.addEventListener('mousedown', (event: MouseEvent) => {\r\n    function is_filled(): boolean {\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mouse_x = event.clientX - rect.left;\r\n        const mouse_y = event.clientY - rect.top;\r\n        // Get the pixel color data of the clicked position\r\n        if(ctx) {\r\n            const image_data = ctx.getImageData(mouse_x, mouse_y, 1, 1).data;\r\n            // Check if the clicked pixel is not white\r\n            if(mouse_x > grid_origin && mouse_x < grid_end + grid_size && mouse_y > grid_origin && mouse_y < grid_end + grid_size) {\r\n                const imageColor = (ctx.getImageData(mouse_x, mouse_y, 1, 1));\r\n                console.log(imageColor.data);\r\n                if (!(\r\n                    // if not white or black\r\n                    image_data[0] === 255 &&\r\n                    image_data[1] === 255 &&\r\n                    image_data[2] === 255\r\n                ) && !  (image_data[0] === 0 &&\r\n                    image_data[1] === 0 &&\r\n                    image_data[2] === 0)) {\r\n                    console.log(\"true\");\r\n                    return true;\r\n                } else {\r\n                    console.log(\"false\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        console.log(\"error\");\r\n        return false;\r\n    }\r\n    // function logic for placing block.\r\n    // is_filled is true if gridsquare you are placing in is occupied.\r\n    function place_block(is_filled: boolean): void {\r\n        const rect = canvas.getBoundingClientRect();\r\n        const mouse_x = event.clientX - rect.left;\r\n        const mouse_y = event.clientY - rect.top;\r\n         // Calculate the row and column in the grid based on the mouse position\r\n         const row = Math.floor((mouse_y - grid_origin) / grid_size);\r\n         const col = Math.floor((mouse_x - grid_origin) / grid_size);\r\n         console.log(row * 20 + col, \"node\");\r\n         console.log(col, \"col\");\r\n         console.log(row, \"row\");\r\n         if(mouse_x > grid_origin && mouse_x < grid_end&& mouse_y > grid_origin && mouse_y < grid_end) {\r\n\r\n         switch (current_mode) {\r\n            case 'start':\r\n                // if block is already placed at cursor, remove block\r\n                if (is_filled) {\r\n                    toggle_fill(canvas, row, col, \"yellow\", true, \"start\");\r\n                    // if block at cursor was the start block, mark it as removed\r\n                    if(row === start.row && col === start.col) {\r\n                        start.placed = false;\r\n                        start_grid_node = -1;\r\n                        console.log(\"hello1\");\r\n\r\n                    } else {\r\n                        // if it was another block, place a start block there instead\r\n                        toggle_fill(canvas, start.row, start.col, \"yellow\", true, \"start\");\r\n                        start_grid_node = col+20*row;\r\n                        console.log(\"hello2\");\r\n\r\n                    }\r\n                    // else if there is no block at cursor\r\n                } else {\r\n                    // remove old start block and place new start block on new place\r\n                    if (start.placed === true) {\r\n                        toggle_fill(canvas, start.row, start.col, \"yellow\", true, \"start\");\r\n                        toggle_fill(canvas, row, col, \"yellow\", false, \"start\");\r\n                        start_grid_node = col+20*row;\r\n                        console.log(\"hello3\");\r\n\r\n                        // if no start block is placed anywhere and cursor on blank space place start.\r\n                    } else {\r\n                        toggle_fill(canvas, row, col, \"yellow\", false, \"start\");\r\n                        start.placed = true;\r\n                        start_grid_node = col+20*row;\r\n                        console.log(\"hello4\");\r\n\r\n                    }\r\n                }\r\n                start.row = row;\r\n                start.col = col;\r\n                break;\r\n            case 'goal':\r\n                if (is_filled) {\r\n                    toggle_fill(canvas, row, col, \"green\", true, \"goal\");\r\n                    if(row === goal.row && col === goal.col) {\r\n                        goal.placed = false;\r\n                        goal_grid_node = -1;\r\n                    } else {\r\n                        toggle_fill(canvas, goal.row, goal.col, \"green\", true, \"goal\");\r\n                        goal_grid_node = col+20*row;\r\n                    }\r\n                } else {\r\n                    if (goal.placed === true) {\r\n                        toggle_fill(canvas, goal.row, goal.col, \"green\", true, \"goal\");\r\n                        toggle_fill(canvas, row, col, \"green\", false, \"goal\");\r\n                        goal_grid_node = col+20*row;\r\n                    } else {\r\n                        toggle_fill(canvas, row, col, \"green\", false, \"goal\");\r\n                        goal.placed = true;\r\n                        goal_grid_node = col+20*row;\r\n                    }\r\n                }\r\n                goal.row = row;\r\n                goal.col = col;\r\n                break;\r\n            case 'wall':\r\n                if (is_filled) {\r\n                    toggle_fill(canvas, row, col, \"red\", true, \"wall\");\r\n                } else {\r\n                    toggle_fill(canvas, row, col, \"red\", false, \"wall\");\r\n                }\r\n                break;\r\n            default:\r\n                console.error('No mode selected');\r\n        }\r\n    }\r\n    }\r\n\r\n    place_block(is_filled());\r\n\r\n});\r\n\r\n/**\r\n * Toggles the fill state of a specified square on a canvas based on the given parameters.\r\n * If the square is currently filled and `is_filled` is true, the square will be cleared\r\n * and set to white. If the square is not filled and `is_filled` is false, the square will\r\n * be filled with the specified `fill_color`. Additionally, if the `type` is \"wall\", this\r\n * function will either add or remove a node from a grid structure depending on the fill state.\r\n *\r\n * @param {HTMLCanvasElement} canvas - The canvas element on which the square is to be toggled.\r\n * @param {number} row - The row number of the square in the grid.\r\n * @param {number} col - The column number of the square in the grid.\r\n * @param {string} fill_color - The color to fill the square with if it is not already filled.\r\n * @param {boolean} is_filled - A boolean indicating whether the square is currently filled.\r\n * @param {string} type - The type of the square, which determines additional actions to be taken (e.g., \"wall\").\r\n * @returns {void} Does not return anything.\r\n *\r\n * @example\r\n * // Toggles the fill state of a square at row 2, column 3 on a canvas element \r\n * // and removes the node associated with that square. \r\n * toggle_fill(canvasElement, 2, 3, 'red', false, 'wall');\r\n */\r\nfunction toggle_fill(canvas: HTMLCanvasElement, row: number,\r\n    col: number, fill_color: string,\r\n    is_filled: boolean, type: string): void {\r\n    // Get the 2D rgoalering context for the canvas\r\n    const ctx = canvas.getContext('2d');\r\n\r\n    // Check there is a canvas\r\n    if (!ctx) {\r\n        console.error('Failed to get the canvas 2D context');\r\n        return;\r\n    }\r\n    // Calculate coordinates of the clicked square\r\n    const x = col * grid_size + grid_origin;\r\n    const y = row * grid_size + grid_origin;\r\n\r\n    // Get the color data of the clicked square\r\n\r\n    if (is_filled) {\r\n        // Clear the square if it's already filled with the target color\r\n        fill_square(x, y, grid_size, \"white\");\r\n        const grid_node = col+20*row;\r\n        if(type === \"wall\") {\r\n            add_node(grid, grid_node, rows, cols);\r\n            console.log(\"node added\");\r\n        }\r\n    } else {\r\n        // Fill the square with the specified color if it's not filled\r\n        const grid_node = col+20*row;\r\n        if (type === \"wall\") {\r\n            remove_node(grid, grid_node, rows, cols);\r\n            console.log(\"node removed\");\r\n        }\r\n        fill_square(x, y, grid_size, fill_color);\r\n    }\r\n}\r\n\r\n/**\r\n * Fills a path of squares on the canvas with a specified color.\r\n * @param {HTMLCanvasElement} canvas - The canvas element.\r\n * @param {Array<number>} path - An array containing indices of squares in the path.\r\n * @param {number} rows - The number of rows in the grid.\r\n * @param {string} fill_color - The color to fill the squares with.\r\n * @returns {void} Does not return anything.\r\n */\r\nexport function fill_path(canvas: HTMLCanvasElement, path: Array<number>, \r\n    fastest_path: Array<number>, rows: number, \r\n    fill_color: string, fastest_path_color: string, \r\n    delay: number): void {\r\n    // Get the 2D rgoalering context for the canvas\r\n    const ctx = canvas.getContext('2d');\r\n    // Check there is a canvas\r\n    if (!ctx) {\r\n        console.error('Failed to get the canvas 2D context');\r\n        return;\r\n    }\r\n\r\n\r\n    // draw out all visited squares\r\n    // draw out all visited squares with fill_color\r\n    for(let i = 0; i < path.length; i++) {\r\n        const x_pos = (path[i] % rows) * grid_size + grid_origin;\r\n        const y_pos = Math.floor(path[i] / rows) * grid_size + grid_origin;\r\n\r\n        setTimeout(() => {\r\n            fill_square(x_pos, y_pos, grid_size, fill_color);\r\n        }, delay * i);\r\n    }\r\n\r\n    // Apply fastest_path_color with delay\r\n    for(let i = 0; i < fastest_path.length; i++) {\r\n        const x_pos = (fastest_path[i] % rows) * grid_size + grid_origin;\r\n        const y_pos = Math.floor(fastest_path[i] / rows) * grid_size + grid_origin;\r\n\r\n        setTimeout(() => {\r\n            fill_square(x_pos, y_pos, grid_size, fastest_path_color);\r\n        }, delay * (path.length + i));\r\n    }\r\n        \r\n}\r\n\r\n\r\nlet current_mode: 'start' | 'goal' | 'wall' | null = null;\r\nlet current_algorithm: \"bfs\" | \"dfs\" | \"a_star\" | null = null;\r\n\r\ndocument.getElementById('startButton')?.addEventListener('click', () => {\r\n    current_mode = 'start';\r\n    console.log(\"start\");\r\n});\r\n\r\ndocument.getElementById('goalButton')?.addEventListener('click', () => {\r\n    current_mode = 'goal';\r\n    console.log(\"goal\");\r\n});\r\n\r\ndocument.getElementById('wallButton')?.addEventListener('click', () => {\r\n    current_mode = 'wall';\r\n    console.log(\"wall\");\r\n});\r\n\r\n\r\n\r\ndocument.getElementById('runButton')?.addEventListener('click', () => {\r\n    if (current_algorithm === \"bfs\") {\r\n        const [fastest_path, visited] = bfs(start_grid_node, goal_grid_node, grid);\r\n        run_sim(fastest_path, visited);\r\n    } else if (current_algorithm === \"dfs\") {\r\n        const [fastest_path, visited] = dfs(start_grid_node, goal_grid_node, grid);\r\n        run_sim(fastest_path, visited);\r\n    } else if (current_algorithm === \"a_star\") {\r\n        const [fastest_path, visited] = a_star(start_grid_node, goal_grid_node, grid);\r\n        run_sim(fastest_path, visited);\r\n    } else {\r\n        return null;\r\n    }\r\n});\r\n\r\ndocument.getElementById(\"dfsButton\")?.addEventListener(\"click\", () => {\r\n    current_algorithm = \"dfs\";\r\n});\r\ndocument.getElementById(\"bfsButton\")?.addEventListener(\"click\", () => {\r\n    current_algorithm = \"bfs\";\r\n});\r\ndocument.getElementById(\"a_starButton\")?.addEventListener(\"click\", () => {\r\n    current_algorithm = \"a_star\";\r\n});\r\n\r\nfunction run_sim(fastest_path: Array<number>, visited: Array<number>): void {\r\n    if (fastest_path && fastest_path.length > 0) {\r\n        fill_path(canvas, visited, fastest_path, 20, \"gray\", \"blue\", 50);\r\n        console.log(current_algorithm);\r\n    } else {\r\n        console.error(\"hello.\");\r\n        alert(\"No valid path found.\");\r\n    console.log(current_algorithm);\r\n    }\r\n}\r\n\r\n/** Draws 20x20 grid on startup\r\n * @returns {void} Does not return anything.\r\n */\r\nfunction start_sim(): void {\r\n    draw_grid(20);\r\n}\r\n/** Resets grid structure by generating a new 20x20 grid. Resets grid UI on screen by redrawing it.\r\n * Function is called when pressing the button \"reset\"\r\n * @returns {void} Does not return anything.\r\n */\r\nfunction reset_sim(): void {\r\n    // reset nodes\r\n    grid = generate_2d_grid_adjacency_list(20, 20);\r\n\r\n    // reset grid graphics\r\n    draw_grid(20);\r\n}\r\n\r\nstart_sim();\r\n\r\ndocument.getElementById('resetButton')?.addEventListener('click', () => {\r\n    reset_sim();\r\n});","import { AdjacencyList } from \"./grid\";\r\n/**\r\n * Performs a Depth-First Search (DFS) on a grid represented as an adjacency list, to find a path from a start node to a goal node.\r\n * This function uses a stack to manage the nodes to be visited, marking each visited node to avoid revisiting them. If the goal node\r\n * is reached, the function reconstructs and returns the path from the start node to the goal node, along with the list of visited nodes.\r\n * If the goal is not reachable from the start, the function returns an empty array.\r\n * \r\n * @param {number} start - The identifier of the start node in the grid.\r\n * @param {number} goal - The identifier of the goal node in the grid.\r\n * @param {AdjacencyList} grid - The adjacency list representing the grid, where each key is a node identifier, and the value is an array\r\n * of identifiers for adjacent nodes.\r\n * @returns {Array<Array<number>>} - A 2-element array where the first element is an array representing the path from the start node to the goal\r\n * node (inclusive), and the second element is an array of all visited nodes' identifiers. Returns an empty array if the goal is not reachable.\r\n *\r\n * @example\r\n * // Assuming a predefined AdjacencyList for a 3x3 grid\r\n * const pathAndVisited = dfs(0, 8, grid); // Find path from top-left to bottom-right\r\n * console.log(pathAndVisited[0]); // Logs the path from start to goal\r\n * console.log(pathAndVisited[1]); // Logs the visited nodes\r\n */\r\nexport function dfs(start: number, goal: number, grid: AdjacencyList): Array<Array<number>> {\r\n    const visited = new Set<number>(); // Set to keep track of visited nodes\r\n    const stack: Array<number> = [start]; // Use an array as a stack, push to add, pop to remove\r\n\r\n    const predecessors: Map<number, number> = new Map(); // To reconstruct the path\r\n\r\n    while (stack.length > 0) {\r\n        const current = stack.pop()!; // Remove and get the last element of the stack\r\n\r\n        if (visited.has(current)) {\r\n            continue; // Skip if already visited\r\n        }\r\n\r\n        visited.add(current); // Mark as visited\r\n\r\n        if (current === goal) { // Goal check\r\n            // Reconstruct the path from goal to start\r\n            const path = [goal];\r\n            let step = goal;\r\n            while (predecessors.has(step) && step !== start) {\r\n                step = predecessors.get(step)!;\r\n                path.unshift(step); // Add step to the beginning of the path\r\n            }\r\n            const arr_visited = Array.from(visited);\r\n            return [path, arr_visited];\r\n        }\r\n\r\n        const neighbors = grid.get(current) || [];\r\n        neighbors.forEach(neighbor => {\r\n            if (!visited.has(neighbor)) {\r\n                predecessors.set(neighbor, current); // Set predecessor for path reconstruction\r\n                stack.push(neighbor); // Add neighbor to the stack\r\n            }\r\n        });\r\n    }\r\n\r\n    return []; // Return empty array if the goal is not reachable from the start\r\n}\r\n","/**\r\n * Generates a 2D grid represented as an adjacency list, where each node is connected\r\n * to its immediate neighbors in the cardinal directions (North, South, East, West).\r\n * This function assumes a rectangular grid layout. Each node in the grid is assigned\r\n * a unique identifier, starting from 0 at the top-left corner, moving left to right\r\n * and top to bottom. The adjacency list is implemented as a Map, where each key is\r\n * a node identifier, and the corresponding value is an array of identifiers for\r\n * adjacent nodes.\r\n *\r\n * @param {number} rows - The number of rows in the grid.\r\n * @param {number} cols - The number of columns in the grid. Together with rows, it defines the size of the grid.\r\n * @returns {AdjacencyList} - The adjacency list representing the 2D grid. The type `AdjacencyList` is a Map\r\n *                            where the key is a number (node identifier) and the value is an array of numbers\r\n *                            (identifiers for adjacent nodes).\r\n *\r\n * @example\r\n * // Generate a 3x3 grid\r\n * const adj_list = generate_2d_grid_adjacencyList(3, 3);\r\n * console.log(adj_list);\r\n * // Map(9) {\r\n * //   0 => [ 1, 3 ],\r\n * //   1 => [ 0, 2, 4 ],\r\n * //   2 => [ 1, 5 ],\r\n * //   3 => [ 0, 4, 6 ],\r\n * //   4 => [ 1, 3, 5, 7 ],\r\n * //   5 => [ 2, 4, 8 ],\r\n * //   6 => [ 3, 7 ],\r\n * //   7 => [ 4, 6, 8 ],\r\n * //   8 => [ 5, 7 ]\r\n * // }\r\n *\r\n * Notes:\r\n * - Nodes at the edges of the grid will have fewer adjacent nodes since they cannot connect outside the grid boundaries.\r\n */\r\nexport type AdjacencyList = Map<number, Array<number>>;\r\nexport function generate_2d_grid_adjacency_list(rows: number, cols: number): AdjacencyList {\r\n    const adj_list: AdjacencyList = new Map();\r\n\r\n    for (let row = 0; row < rows; row++) {\r\n        for (let col = 0; col < cols; col++) {\r\n            const node_id = row * cols + col; // Unique ID for each node\r\n            const edges: Array<number> = [];\r\n\r\n            // North\r\n            if (row > 0) edges.push(node_id - cols);\r\n            // South\r\n            if (row < rows - 1) edges.push(node_id + cols);\r\n            // East\r\n            if (col < cols - 1) edges.push(node_id + 1);\r\n            // West\r\n            if (col > 0) edges.push(node_id - 1);\r\n\r\n            adj_list.set(node_id, edges);\r\n        }\r\n    }\r\n\r\n    return adj_list;\r\n}\r\n// access grid position by writing console.log(adj_list.get(gridNr));\r\n\r\nexport function remove_node(adj_list: AdjacencyList, node_id: number, rows: number, cols: number): void {\r\n    // Remove the node itself\r\n    adj_list.delete(node_id);\r\n\r\n    // Potential neighbors\r\n    const neighbors = [\r\n        node_id - 1,    // West\r\n        node_id + 1,    // East\r\n        node_id - cols, // North\r\n        node_id + cols  // South\r\n    ];\r\n\r\n    // Remove the node from its neighbors' adjacency lists\r\n    neighbors.forEach(neighbor_id => {\r\n        if (adj_list.has(neighbor_id)) {\r\n            const updated_edges = adj_list.get(neighbor_id)!.filter(edge => edge !== node_id);\r\n            adj_list.set(neighbor_id, updated_edges);\r\n        }\r\n    });\r\n}\r\n\r\nexport function add_node(adj_list: AdjacencyList, node_id: number, rows: number, cols: number): void {\r\n    const row = Math.floor(node_id / cols);\r\n    const col = node_id % cols;\r\n    const edges: Array<number> = [];\r\n\r\n    // Determine valid adjacent nodes based on the grid structure\r\n    if (row > 0) edges.push(node_id - cols);    // North\r\n    if (row < rows - 1) edges.push(node_id + cols); // South\r\n    if (col > 0) edges.push(node_id - 1);       // West\r\n    if (col < cols - 1) edges.push(node_id + 1);   // East\r\n\r\n    // Add the node back with its edges\r\n    adj_list.set(node_id, edges);\r\n\r\n    // Add this node back to its neighbors' adjacency lists\r\n    edges.forEach(neighbor_id => {\r\n        if (adj_list.has(neighbor_id) && !adj_list.get(neighbor_id)!.includes(node_id)) {\r\n            adj_list.get(neighbor_id)!.push(node_id);\r\n        }\r\n    });\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(250);\n"],"names":["q","e","tail_index","head_index","console","log","slice","dist_to_node","n1","n2","current_x_pos","rows","grid_size","grid_origin","current_y_pos","Math","floor","goal_x_pos","goal_y_pos","abs","start","goal","grid","visited","Set","next","predecessors","Map","distance","add","set","f","g","h","current","Array","from","reduce","a","b","get","path","undefined","unshift","delete","forEach","neighbor","new_g","has","Infinity","size","queue","empty","enqueue","head","dequeue","step","is_empty","canvas","document","getElementById","window","innerWidth","innerHeight","ctx","getContext","height","grid_end","generate_2d_grid_adjacency_list","placed","row","col","start_grid_node","goal_grid_node","draw_grid","n_of_squares","grid_x","grid_y","fill_square","error","x","y","color","clearRect","fillStyle","fillRect","toggle_fill","fill_color","is_filled","type","grid_node","add_node","remove_node","fill_path","fastest_path","fastest_path_color","delay","i","x_pos","y_pos","setTimeout","length","addEventListener","event","rect","getBoundingClientRect","mouse_x","clientX","left","mouse_y","clientY","top","current_mode","place_block","image_data","getImageData","data","imageColor","current_algorithm","run_sim","alert","bfs","dfs","a_star","stack","pop","push","cols","adj_list","node_id","edges","neighbor_id","updated_edges","filter","edge","includes","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}